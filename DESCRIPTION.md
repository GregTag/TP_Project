# TCP chat project

## Структура

- Есть клиенты и сервер. 
- Клиент подключается к серверу. При подключении он становится анонимом.
- Аноним может авторизоваться при помощи логина и пароля. После авторизации он становится пользователем.
- Клиент может узнать список всех доступных ему комнат. Клиент может войти в доступную ему комнату.
- Аноним может читать сообщения в комнатах, предназначенных для анонимов.
- Пользователь может узнать свои права в какой-то комнате.
- Если у пользователя достаточно прав, то он может:
    * запросить историю сообщений в комнате
    * запросить список имён пользователей в комнате
    * получать сообщения из комнаты
    * отправлять сообщения всем в комнате
    * отправить личное сообщение другому пользователю в комнате
- Клиент может выйти из комнаты, в которую он входил.
- Сервер может отправить сообщения-объявления по всем комнатам

## Архитектура

![Class Diagram did not loaded :(](ClassDiagram.svg "Class Diagram")

### Server side

* Точка входа - объект класса `Server`. При остановке сервера деструктор удаляет все объекты, связанные со системой. Чтобы начать работу сервера необходимо вызвать метод `startListening()`. После этого клиент может подключиться к серверу. При подключении к серверу создаётся объект класса `ServersideClientHandler` и записывается в поле объекта сервера. Дальнейшее взаимодействие клиента происходит через обработчик. 
* Классы `PermissionsBank`, `Room` и `Account` работают с данными:
    * PermissionsBank подгружает разрешения пользователей в комнатах.
    * Созданные объекты классов Account и Room могут быть сохранены и загружены по своим id.
* Класс `Socket` реализует протокол взаимодействия по сети между серверным и клиентскими приложениями.
* Интерфейс `Request` устанавливает формат сообщений, которыми обмениваются клиент и сервер. Отправляющая сторона создаёт объект класса, который реализует интерфейс `Request`. С помощью виртуального методам `getQuery()` происходит сериализация этого объекта в строку. Эту строку передаём принимающей стороне. Принимающая сторона вызывает `RequestParser.parse(data)`, который создаёт точную копию исходного объекта. Дальше принимающая сторона обрабатывает этот с помощью вызова нужного метода `handle()`.
* Сообщения создаются по средствам классов, реализующий интерфейс `Message`, который является наследником интерфейса `Request`. Механизм сообщений реализован с помощью паттерна "декоратор", благодаря чему возможны различные комбинации свойств сообщений. Для упрощения создания сообщений используется класс `MessagesFacade`, реализующий паттерн фасад.
* Для создания типовых сообщений и запросов используется класс `RequestCreators`.

### Client side

В пользовательской программе создаётся класс - наследник класса `ClientsideHandler`. Взаимодействие с серверной частью происходит через методы этого класса, в том числе, благодаря виртуальным методам, просходит взаимодействие с пользовательским интерфейсом.
