# TCP chat project

## Структура

- Есть клиенты и сервер. 
- Клиент подключается к серверу. При подключении он становится анонимом.
- Аноним может авторизоваться при помощи логина и пароля. После авторизации он становится пользователем.
- Пользователь может узнать список всех доступных ему комнат. Пользователь может войти в доступную ему комнату.
- Пользователь получает сообщения из комнат, в которые он вошёл
- Пользователь может узнать свои права в какой-то комнате.
- Если у пользователя достаточно прав, то он может:
    * запросить историю сообщений в комнате
    * запросить список имён пользователей в комнате
    * отправлять сообщения всем в комнате
    * отправить личное сообщение другому пользователю в комнате
    * управлять разрешениями *(добавлено как фича)*.
- Пользователь может выйти из комнаты, в которую он входил.
- Сервер может отправить сообщения-объявления по всем комнатам

## Архитектура

![Class Diagram did not loaded :(](ClassDiagram.svg "Class Diagram")

### Используемые паттерны

* Строитель: класс `MessagesBuilder`. Предоставляет удобный интерфейс для создания сообщений всех видов.
* Синглетон: классы `Logger`, `AccountDatabase`, `PermissionsBank`. Позволяет из любого места обратиться к объекту через класс.
* Мост: классы `ClientsideHandler` и `MessagesRenderer`. Позволяет разделить логику обработки сообщений от отрисовки сообщений. Также позволяет заменить интерфейс рендеринга сообщений (консольный, графический) без изменений их обработки.
* Компоновщик/Декоратор: все классы, реализующие интерфейс `Message`: `BaseMessage` класс, объекты которого будут оборачивать, который является листом в бамбуке компоновщика. `PropertiesDecorator` абстрактный класс, от которого наследуются остальные декораторы. С одной стороны это компоновщик, потому что эти классы позволяют добавить новые свойства к сообщению, а итоговое сообщение это сумма всех свойств, с другой стороны являются это декораторы, потому что каждый из них оборачивает ровно 1 объект, а также могут изменять логику поведения объекта в целом. Так, например, обработка всего сообщения на сервере зависит лишь от внешнего слоя, обработчик не смотрит внутрь, а отрисовка и отправка сообщений вызываются рекурсивно от внешнего слоя до самого внутреннего `BaseMessage`.
* Фасад: классы `RequestCreator`, `Socket`. Класс `RequestCreator` предоставляет ещё более простой в использовании интерфейс создания запросов, используя класс `MessagesBuilder`, но не только его. Класс `Socket` предоставляет необходимый интерфейс для использования библиотеки `boost::asio` и его собственных сокетов.
* Посетитель: классы, реализующие интерфейс `Request` и классы обработчиков: `ClientsideHandler` и `ServersideHandler`. Реализуется механизм тройной диспетчеризации:
    1. Клиент инициализирует обработку запроса по средствам вызова виртуального метода `handler.recieve(Request)`.
    2. В методе `recieve`, благодаря виртуальности этого метода, запросу передаётся объект обработчика конкретного типа `request.handle(handler)` и соответственно вызывается нужная перегрузка `handle` и выполнение переходит к запросу.
        1) Если обработчик это `ServersideHandler`, то сообщение отправляется в нужную комнату нужным пользователям.
        2) Если обработчик это `ClientsideHandler`, то запрос запрашивает объект `MessageRenderer`, после чего вызывает нужный метод `render...`, соответсвующий типу текущего запроса и последовательно спускается внутрь декораторов.
    3. Далее выполнение переходит уже `MessageRenderer`'у, который занимается отрисовкой сообщения. Когда запрос доходит до нижнего уровня `BaseMessage`, то происходит вывод сообщения.

### Server side

* Точка входа - объект класса `Server`. При остановке сервера деструктор удаляет все объекты, связанные со системой. После создания объекта сервера клиент может подключиться к нему. При подключении к серверу создаётся объект класса `ServersideHandler` и записывается в список `clients` сервера. Дальнейшее взаимодействие клиента происходит через этот обработчик. 
* Классы `PermissionsBank`, `Room` и `Account` работают с данными:
    * `PermissionsBank` управляет разрешения пользователей в комнатах. За хранение, чтение и запись отвечает класс `ServerPermissionsBank`.
    * Созданные объекты классов `Account` могут быть сохранены и загружены по своим id. За это отвечает класс `SimpleDatabase`, наследующийся от абстрактного класса `AccountDatabase`. 
* Класс `AccountDatabase` использует паттерн синглетон. В качестве instance записан наследник `SimpleDatabase`, который инициализируется в main'е.
* Класс `Socket` реализует протокол взаимодействия по сети между серверным и клиентскими приложениями.
* Класс `Room` является лёгким, хранит в себе id и файл, откуда читать и куда записывать историю. Объект этого класса создаётся при запросе первого клиента войти в комнату. 
* Интерфейс `Request` устанавливает формат сообщений, которыми обмениваются клиент и сервер. Отправляющая сторона создаёт объект класса, который реализует интерфейс `Request`. С помощью виртуального метода `getQuery()` происходит сериализация этого объекта в строку. Эту строку передаём принимающей стороне. Принимающая сторона вызывает `RequestParser.parse(data)`, который создаёт точную копию исходного объекта. Дальше принимающая сторона обрабатывает этот с помощью вызова нужного метода `handle()`.
* Сообщения создаются по средствам классов, реализующий интерфейс `Message`, который является наследником интерфейса `Request`. Механизм сообщений реализован с помощью паттерна "декоратор", благодаря чему возможны различные комбинации свойств сообщений. 
* Для упрощения создания сообщений используется класс `MessagesBuilder`. Этот класс позволяет создавать сообщения цепочкой вызовов своих методов, вместо самостоятельного вызова всех нужных конструкторов у декораторов.
* Для создания типовых сообщений и запросов, которые чаще всего и будут создаваться, используется класс `RequestCreators`.
* Класс `ServerLogger` отвечает за логи. Нужную информацию дублирует и в консоль и в файл лога. Доступен из любой строчки кода через интерфейс `Logger`.
* Класс `ConsoleHandler` отвечает за обработку команд из консоли сервера.

### Client side

* В пользовательской программе есть класс, наследующийся от абстрактного класса `MessageRenderer`, который отвечает за отрисовку сообщений.
* Создаётся объект класса `ClientsideHandler`. Взаимодействие с серверной частью происходит через методы этого класса, также, объект рендеринга лежит внутри обработчика и обработчик имеет к нему доступ.
* Класс `DebugLogger` отвечает за логи, которые он пишет в лог файл. Доступен из любой строчки кода через интерфейс `Logger`.
* Класс `ConsoleHandler` отвечает за обработку команд из консоли.
